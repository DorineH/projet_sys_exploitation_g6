import threading
import random
import graphviz
import time

#-------------------------------------------------------------- CLASS TASK  --------------------------------------------------------------------------------

class Task:

    def __init__(self, name, reads, writes, func):
        self.name= name
        self.reads = reads
        self.writes = writes
        self.func = func
        self.lock = threading.Lock() # ajout du verrou
        self.dependents = []

# initialisation des tâches 
T1 = Task("T1",  ['M1'],['M4'], lambda: print("Exécution de la tâche : T1 "))
T2 = Task("T2", ["M3","M4"], ["M1"], lambda: print("Exécution de la tâche : T2"))  
T3 = Task("T3", ["M3","M4"], ["M5"] , lambda: print("Exécution de la tâche : T3")) 
T4 = Task("T4", ["M4"], ["M2"], lambda: print("Exécution de la tâche : T4")) 
T5 = Task("T5", ["M5"], ["M5"], lambda: print("Exécution de la tâche : T5" )) 
T6 = Task("T6", ["M1", "M2"],["M4"], lambda: print("Exécution de la tâche : T6")) 

# initialisation du système de tâches 
s1 = TaskSystem([T1, T2, T3, T4, T5, T6], {T1: [], T2: [T1], T3: [T1],T4: [T2, T3], T5: [T3], T6: [T4, T5]})


class TaskSystem:
    def __init__(self, t_taches, t_dictPrec):
      self.taches = t_taches
      self.dictPrec = t_dictPrec
      self.check_inputs(self.taches, self.dictPrec)
      self.para_max = False
    #---------------------------------------------------------VALIDATION DES ENTREES -----------------------------------------------------------------------------
    def check_inputs(self, tasks, dependencies):
    # deux taches de meme nom
      for task in tasks:
        if task.name in set(tasks):
            print(f"Erreur: la tâche '{task[tasks.name]}' existe déjà ")
            return False
      
        
        for dependency in self.dictPrec:
              if dependency not in tasks:
                  print(f"Erreur: {dependency.name} n'existe pas dans la liste des tâches !")
                  return False
              
        
        return "Système de tâche crée"
        
    # ---------------------------------------------------- JEU DE DONNEES RANDOMNISE---------------------------------------------------------------------------------
    def get_Random_Variable_And_Store_It(self,variables_prenables):
      nb_action = random.randint(1, 3) #3 variables max pour lecture ou écriture (choix arbitraire)
      variables = []
      for x in range(nb_action):
        var = random.choice(variables_prenables)
        variables.append(var)
      return variables

    def get_Random_Dataset(self):
        #on créer un nb aléatoire de variables 
        variables_prenables = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]
        #On genere un chiffre qui sera le nb de variables utilisées par le système de tâche
        nb_de_variables = random.randint(2,10)
        jeu_de_variables_aleatoires = []

        #Pour le nb de variables on fait un choix aléatoire sur le nom de ces variables (parmi les lettres ci dessus)
        for x in range(nb_de_variables):
          variable = random.choice(variables_prenables)
          jeu_de_variables_aleatoires.append(variable)

        action_possible = [0,1,2] #0 -> lecture, 1 -> ecriture, 2 -> les deux 

        #Pour chaque tâche du système de tâche, on choisi aléatoirement si elle écrira, lira des variables ou les deux 
        for taches in self.taches:
          action = random.choice(action_possible)

          #Si 0 est l'action choisie, alors on appelle la fonction qui selectionne x variables et qui les ajoute dans les caractéristiques de la tâche 
          if(action == 0):  
            taches.reads = self.get_Random_Variable_And_Store_It(variables_prenables)

          #Même chose si la tâche ne fait qu'écrire dans une variable 
          elif(action == 1):
            taches.writes = self.get_Random_Variable_And_Store_It(variables_prenables)

          #Même chose si la tâche écrit et lit 
          elif(action == 2):
            taches.reads = self.get_Random_Variable_And_Store_It(variables_prenables)
            taches.writes = self.get_Random_Variable_And_Store_It(variables_prenables)

    def detTestRnd(self):
      determinisme = True
      #Génération puis test des conditions de Bernstein sur 5 jeux de données différents
      for i in range(5):  
        self.get_Random_Dataset() #Ajoute des variables de lecture et/ou d'écriture à toute les tâches du système
        Bernstein_test(couple_a_Berstein) #Vérification du déterminisme en testant les cdtion de Berstein
        if(type(Bernstein_test==str)): #Si la fonction Berstein_test renvoi un string c'est un message d'erreur qui indique que le système n'est pas deterministe
          determinisme = False
        else:
          pass
      if(determinisme == True):
        print("Le résultat du test randomisé indique que le sysème de tâche est bien deterministe peu importe les variables")
      else:
        print("Le résultat du test randomisé indique que le sysème de tâche n'est pas deterministe")

     
    #-----------------------------------------------------RUN SEQUENTIEL -----------------------------------------------------------------
    #l'objectif de cette fonction est d'executer les tâches de maniere séquentielle tout en respecter les dépendances de chaque tâche
    # fonction pour exécuter une tâche
    def execute_task(self,task):
        print(f"Exécution de la tâche {task.name}")
        task.func()

    # fonction récursive pour exécuter les tâches
    def run_seq_intermediaire(self, task, completed_tasks):
        # vérifier si la tâche a déjà été exécutée
        if task in completed_tasks:
            return
        # exécuter les tâches dépendantes
        for dependent_task in self.dictPrec[task]:
            self.run_seq_intermediaire(dependent_task, completed_tasks)
        # exécuter la tâche actuelle
        self.execute_task(task)
        # ajouter la tâche terminée à la liste des tâches complétées
        completed_tasks.append(task)

    def runSeq(self):
        # exécuter les tâches dans l'ordre correct
        completed_tasks = []
        for task in self.dictPrec:
            self.run_seq_intermediaire(task, completed_tasks)


    #-------------------------------------------------------------- EXECUTION EN PARALELLE --------------------------------------------------------------------------------
    #L'objectif de cette fonction est d'executer les tâches de maniere paralelle, c'est à dire que certaine tâche s'excute en meme temps, en respectant les dependances.
    #cette fonction de ne fonctionne pas, je pense que c'est un probleme de verouillage du thread de la tâche 1
            
    # fonction qui execute une tâche et ses dépendances
    def run_one_task(self, task):
        # attente des semaphores de toutes les tâches précédentes
        for dependency in self.dictPrec[task]:
              dependency.lock.acquire()
              
        # execution de la tâche
        print("Commencement de la tache", task.name )
        #task.acquire_lock() # verrouillage avant execution
        task.func()
        #task.release_lock() # deverouillage apres execution
        print("Tache", task.name, "terminée", " \n")
        
        # liberation des semaphores pour les tâches suivantes
        for dependent in task.dependents:
            dependent.lock.release()
            
    # fonction qui lance toutes les taches
    def run(self):
        # creation des threads pour toutes les tâches
        threads = [threading.Thread(target=self.run_one_task, args=(task,)) for task in self.dictPrec]

        # démarrage des threads
        for thread in threads:
            thread.start()


        # libération du sémaphore de la première tâche
        #T1.semaphore.release()
        
        # attente de la fin de tous les threads
        for thread in threads:
            thread.join()

#-------------------------------------------------------------- PARALELLISME MAXIMAL 1/3 PREPARATION DES VARIABLES ---------------------------------------------------------------------
#Liste contenant tous les chemins :
liste_chemins = []

#récupération de tous les couples de tâches reliées (ex : si A -> B alors on ajoute ["A", "B"] à la liste "taches_direct_reliees")
def Get_couple_path(systeme_tache): 
  taches_direct_reliees =[]
  for key, values in systeme_tache.dictPrec.items():
    for value in values:
        taches_direct_reliees.append([value.name, key.name])

  return taches_direct_reliees


#Récupération des plus grands chemins du graphe, en reliant plusieurs tâches directement reliées entre elle 
#exemple : si ["A", "B"] et ["B", "C"] alors nouveau chemin : ["A", "B", "C"]

def GetPath(liste, systeme_tache):
  #Variable de stockage des couples de chemins directement reliés
  global taches_direct_reliees 
  taches_direct_reliees = Get_couple_path(systeme_tache)

  #Enregistre si l'un des chemins a évolué (une variable a été rajouté dans l'un d'entre eux)
  change = False 
  liste_temporaire = [] 
  
  #On parcours les listes de chemins contenus dans la variable passée en argument 
  for chemin in liste: 
    #Puis pour chaque couple de tâche de la liste taches_direct_reliees :
    for i in range(0,len(taches_direct_reliees)):
      derniere_tache_du_chemin = chemin[-1]
      premiere_tache_du_chemin = chemin[0]

      #Pour chaque chemins on cherche si une des extrémités du chemin est directemement reliée à une autre tâche en vue de completer le chemin, 
      #ex :  on sait que "A" et "B" sont reliés, ainsi si on a un chemin ["X", "Y", "A"] on peut l'enrichir du "B" en dernière position

      if(derniere_tache_du_chemin == taches_direct_reliees[i][0]): 
        liste_temporaire.append(premiere_tache_du_chemin)
        liste_temporaire.append(derniere_tache_du_chemin)
        liste_temporaire.append(taches_direct_reliees[i][-1])
        change= True 

        #si le chemin construit est > que taches_direct_reliees alors on peut l'ajouter à notre liste de chemins
        if(len(chemin) > len(taches_direct_reliees[i])): 
          index = liste.index(chemin) 
          liste_chemins[index].append(taches_direct_reliees[i][-1])
        else:
          liste_chemins.append(liste_temporaire)
        
        liste_temporaire = []
  #tant que l'un des chemins à été agrandit on fait une récursion sur la fonction avec la nouvelle liste de chemins
  if(change==True):
    return GetPath(liste_chemins, systeme_tache)

  #une fois qu'aucun changement ne s'est produit, on supprime les chemins qui se repètent pour ne garder que les plus grands
  return delete_dupplicated_path(liste_chemins)


#Suppression des chemins intermédiaires qui se retrouvent dans d'autres chemins
#exemple : si l'on a [["A", "B"], ["A", "B", "C"]] on souhaite garder que la seconde liste
def delete_dupplicated_path(liste_chemins):
  already_here=False
  liste_unique = []
  for chemins in liste_chemins:
    for chemins_deja_inclus in liste_unique:
      #Si le chemin actuellement observé se trouve déjà intégralement dans un chemin déjà ajouté à la liste de chemins unique
      #Le test passe à True 
      already_here = set(chemins).issubset(chemins_deja_inclus)
      if(already_here==True):
        #Si le test passe à True alors on passe au chemin suivant
        break
    if(chemins not in liste_unique and already_here==False):
      #Si le chemin ne se trouve pas déjà dans un chemin alors on l'ajoute à la liste de chemins unique
      liste_unique.append(chemins)
  return liste_unique 


    #-------------------------------------------------------------- PARALELLISME MAXIMAL 2/3 DETERMINISME ---------------------------------------------------------------------
#Recherche des tâches qui sont parallèles (2 prochaines fonctions):

#Générer une liste avec tous les couples de tâches possible à partir des tâches déclarées dans le système

def identify_couple(liste):
  couple_tache = []
  for i in range(len(liste)):
    for tache_1 in liste[i]:
      for y in range(len(liste)):
        for tache_2 in liste[y]:
          
          couple_temp = [tache_1, tache_2]
          couple_temp_envers = [tache_2, tache_1]
          if(couple_temp in couple_tache or couple_temp_envers in couple_tache or tache_1 == tache_2):
            pass
          elif(couple_temp not in taches_direct_reliees and couple_temp_envers not in taches_direct_reliees):
            couple_tache.append([tache_1, tache_2])
  return couple_tache

#Suppression des couples de tâches qui se trouvent au sein d'un même chemin (et qui ont donc une relation de dépendance directe ou indirecte)
#puis rendu de la liste avec les couples de tâches qui sont parallèles

def get_para_task(systeme_tache):
  liste_traitee = identify_couple(GetPath(Get_couple_path(systeme_tache),systeme_tache))
  liste_chemins = GetPath(Get_couple_path(systeme_tache), systeme_tache)
  couple_to_test = []
  for couple in liste_traitee:
    tache1 = couple[0]
    tache2 = couple[1]
    chemins_tache1 = [tuple(chemin) for chemin in liste_chemins if tache1 in chemin]
    chemins_tache2 = [tuple(chemin) for chemin in liste_chemins if tache2 in chemin]
    if len(set(chemins_tache1).intersection(set(chemins_tache2))) == 0 and couple not in couple_to_test:
      couple_to_test.append(couple)
  return couple_to_test


#---Verification determinisme (2 prochaines fonctions):
#Vérification du déterminisme 
#Vérification des conditions de Bernstein pour les couples de tâches isolées 
def interference(couple_tache, systeme_tache):
  #Creation d'un dictionnaire contenant pour chaque tâches déclarées son domaine de lecture et d'écriture
  domaine_lecture = {}
  domaine_ecriture = {}

  for tache in couple_tache:
    #récupération de l'objet Task nommé tache 
    for elem in systeme_tache.taches:
        if(elem.name == tache):
          tache = elem

    domaine_lecture[tache.name] = tache.reads
    domaine_ecriture[tache.name] = tache.writes

  tache_1 = couple_tache[0]
  tache_2 = couple_tache[1]
  interferentes = True
  
  #Création de variables qui continnent les variables d'écriture ou de lecture de chacune des tâches du couple
  tache_1_ecrit =[tuple(elem) for elem in domaine_ecriture[tache_1]]
  tache_1_lect = [tuple(elem) for elem in domaine_lecture[tache_1]]
  tache_2_ecrit =[tuple(elem) for elem in domaine_ecriture[tache_2]]
  tache_2_lect = [tuple(elem) for elem in domaine_lecture[tache_2]]

  #Si les tâches respectent une des trois conditions de Bernstein alors on passe interferentes à True
  #Les conditions sont réalisées par des comparaisons entre les variables précédentes et des ensembles crées temporairement pour une comparaison plus rapide  
  if len(set(tache_1_lect).intersection(set(tache_2_ecrit))) ==0 and len(set(tache_2_lect).intersection(set(tache_1_ecrit))) ==0 and len(set(tache_1_ecrit).intersection(set(tache_2_ecrit)))==0 :
    interferentes = False

  return interferentes 

#Appel de la fonction précédente et selon son résultat affichage d'un message d'erreur ou non
def Bernstein_test(liste_couple_a_test, systeme_tache):
  #Pour chaque couple de tâches, appel de la fonction qui retourne un booléen selon le respect ou non respect des conditions de Bernstein 
  for couple in liste_couple_a_test:
    if(interference(couple, systeme_tache) == True):
      error_msg = "Certaines tâches parallèles sont interférentes, veuillez redéfinir le graphe correctement"
      return error_msg
    else:
      continue

#-------------------------------------------------------------- PARALELLISME MAXIMAL 3/3 L'ALGORITHME ---------------------------------------------------------------------

#Création de la matrice des chemins en créant une instance de liste de forme ["A", "B"] pour toutes les taches reliees par un chemin
def matriceChemins():
  couples = []
  #Parcours des chemins
  for chemin in liste_chemins:
      for i in range(len(chemin)-1):
      #tache i du chemin à partir de laquelle on va créer des couples de tache la contenant ainsi que les taches qui la suivent dasn les chemins où elle se trouve
          tache1 = chemin[i]
          #Parcours de toutes les tâches suivants la tâche1 dans le chemin en cours 
          for j in range(i+1, len(chemin)):
              tache2 = chemin[j]
              couples.append([tache1, tache2])
  return couples

#A partir de la matrice des chemins, conception de la liste d'adjacence
def GetlisteAdjacence(matrice_des_chemins, systeme_tache):
  taches_a_conserver = []
  #Pour chaque couple de tache présents dans la matrice des chemins, test des conditions de Bernstein 
  for couple in matrice_des_chemins:
    taches_interferentes = interference(couple, systeme_tache)
    if(taches_interferentes==False): 
      pass
    #si les taches ne respectent pas les conditions de Berstein, alors on les stocke dans une liste
    elif(taches_interferentes==True and couple not in taches_a_conserver): 
      taches_a_conserver.append(couple)
  #Construction de la liste d'adjacence sous forme d'un dictionnaire
  liste_adjacence = {}

  for elem in taches_a_conserver:
    if(elem[0] not in liste_adjacence):
      #Pour chaque tâche en position 0 des couples de la matrice des chemins on crée une clé de dictionnaire
      tache_1 = elem[0]
      liste_adjacence[tache_1] = []
      for i in range(len(taches_a_conserver)):
        #on ajoute ensuite les tâches en deuxième position des couples de la matrice des chemins dans la liste
        if(tache_1 != taches_a_conserver[i][0]):
          pass
        else:
          liste_adjacence[tache_1].append(taches_a_conserver[i][1])

  return liste_adjacence

#On va supprimer les redondances qui se trouvent dans notre système de tâche
def DeleteRedundancies(dict_liste_adjacence):
  redundancy = False
  arcs_redondants = []
  #Pour chaque instance du dictionnaire représentant la liste d'adjacence du système de tâches
  for nom_tache, liste_taches_liees in dict_liste_adjacence.items():
  #On regarde pour chaque liste, pour chaque taches si celle-ci se retrouve dans les liste d'adjacence des autres tâches présentent dans cette liste
    for tache_liee_1 in liste_taches_liees:
      #On ne compare pas la tâche avec elle même
      for tache_liee_x in liste_taches_liees: 
        if(tache_liee_1 == tache_liee_x): #on exclue la tache 1 pour pouvoir comparer seulement les taches restantes 
          pass
        else:
          #Si c'est le cas, alors on passe la variable redundancy à True
          if(tache_liee_x in dict_liste_adjacence.keys() and tache_liee_1 in dict_liste_adjacence[tache_liee_x]):
            redundancy = True
           #Si la tâche n'est pas présente dans l'une des listes d'adjacence des autres tâches de la liste, alors la liaison n'est pas redondante, 
           #arrêt de la boucle sur cette tâche
          else:
            redundancy = False
            pass 

      #Si à ce stade du programme redundancy est toujours True, l'une des tâches se retrouve dans la liste d'adjacence de 
      #toutes les autres tâches présentent dans cette liste d'adjacence   
      if(redundancy == True):
        #On ajoute la clé de la liste ainsi que la tâche qui était en observation à une liste 
        arcs_redondants.append([nom_tache,tache_liee_1])

    #On supprime les dépendances qui étaient créees pour chacune des redondances trouvées
    for couple_redondant in arcs_redondants:
      tache_1 = couple_redondant[0]
      tache_2 = couple_redondant[1]
      dict_liste_adjacence[tache_1].remove(tache_2)

    #On retourne la liste d'adjacence nettoyée de toute redondance
    return dict_liste_adjacence

#--------------------------------------------------------------------lancement du parallélisme maximal  ---------------------------------------------------------------------------

#A certains endroit de notre code il est plus aisé de travailler avec le nom des tâches
#et non pas l'objet Task lui même, ici il s'agit de transformer un nom de tâche en objet Task 
def getTaskObject(systeme_tache, nom_tache):
  for elem in systeme_tache.taches:
    if(elem.name == nom_tache):
      return elem

#Génère un dictionnaire avec les relations de précédences de toute les tâches suite à l'opération de parallélisation max, 
#Le dictionnaire remplace ensuite l'ancien des dépendances dans le système de tâche
def getParaMax(systeme_tache):
      global liste_adjacence_without_redundancies
      couple_a_test = get_para_task(systeme_tache)
      dict_precedences  = {}
      if(type(Bernstein_test(couple_a_test, systeme_tache)) == str):
          return Bernstein_test(couple_a_test, systeme_tache)
      else:
          matrice_chemins = matriceChemins()
          liste_adjacence = GetlisteAdjacence(matrice_chemins, systeme_tache)
          liste_adjacence_without_redundancies = DeleteRedundancies(liste_adjacence)
          
          for key, liste_taches in liste_adjacence_without_redundancies.items():
              for tache in liste_taches:
                  tache_obj = getTaskObject(systeme_tache, tache)
                  key_obj = getTaskObject(systeme_tache, key)
                  if(tache_obj not in dict_precedences.keys()):
                      #on créer un liste qui contiendra les taches précédentes de la tache 
                      dict_precedences[tache_obj] = []
                  dict_precedences[tache_obj].append(key_obj) #on ajoute la première tache précédente de la tache à partir des listes d'adjacences
      systeme_tache.dictPrec = dict_precedences
      systeme_tache.para_max == True


#Fonction d'affichage des dépendances suivant le parallélisme maximal d'un tâche indiquée

def getDependencies(systeme_tache, NomTache):
  liste_nom_tache = []
  #On exécute la fonction de para max si pour ce système de tâche cela n'a pas encore été effectué
  if(systeme_tache.para_max==False):
    getParaMax(systeme_tache)

  #Les taches sont sous forme d'objets Task peu équivoque ainsi on affiche les noms 
  for tache_obj in systeme_tache.dictPrec[NomTache]:
    liste_nom_tache.append(tache_obj.name)

  #on retourne la liste des dépendance sous leur nom 
  return liste_nom_tache
  
#-----------------------------------------------------------------------Affichage d'un graphe selon le para max- --------------------------------------------------------------------

def draw(systeme_tache):

  taches_formatees_dot = "{rankdir=TB ;" 
  for tache, taches_precedentes in liste_adjacence_without_redundancies.items():
    i=0
    taches_formatees_dot+= tache + '->'
    for elem in taches_precedentes:
      taches_formatees_dot+= elem

      if(i==len(taches_precedentes)-1):
        taches_formatees_dot+= ";" #ajout d'un ";" entre les successions de tâches
      else:
        taches_formatees_dot+="," #ajout d'une virgule entre chaque tâches successives
      i+=1

  taches_formatees_dot+="}" #fermeture par une accolade à la fin du parcours
  dot = graphviz.Source(f'digraph "Systeme de taches avec parallélisme maximal" {taches_formatees_dot}')
  return dot

