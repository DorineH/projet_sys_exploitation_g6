import threading
import random
import time
import graphviz

class TaskSystem:
    def __init__(self, t_taches, t_dictPrec):
      self.taches = t_taches
      self.dictPrec = t_dictPrec
      self.check_inputs(self.taches, self.dictPrec)
      self.para_max = False
    #---------------------------------------------------------VALIDATION DES ENTREES -----------------------------------------------------------------------------
    def check_inputs(self, tasks, dependencies):
    # deux taches de meme nom
      for task in tasks:
        if task.name in set(tasks):
            print(f"Erreur: la tâche '{task[tasks.name]}' existe déjà ")
            return False
      
        
        for dependency in self.dictPrec:
              if dependency not in tasks:
                  print(f"Erreur: {dependency.name} n'existe pas dans la liste des tâches !")
                  return False
              
        
        return "Système de tâche crée"
        
    # ---------------------------------------------------- JEU DE DONNEES RANDOMNISE---------------------------------------------------------------------------------
    def get_Random_Variable_And_Store_It(self,variables_prenables):
      nb_action = random.randint(1, 3) #3 variables max pour lecture ou écriture (choix arbitraire)
      variables = []
      for x in range(nb_action):
        var = random.choice(variables_prenables)
        variables.append(var)
      return variables

    def get_Random_Dataset(self):
        #on créer un nb aléatoire de variables 
        variables_prenables = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]
        #On genere un chiffre qui sera le nb de variables utilisées par le système de tâche
        nb_de_variables = random.randint(2,10)
        jeu_de_variables_aleatoires = []

        #Pour le nb de variables on fait un choix aléatoire sur le nom de ces variables (parmi les lettres ci dessus)
        for x in range(nb_de_variables):
          variable = random.choice(variables_prenables)
          jeu_de_variables_aleatoires.append(variable)

        action_possible = [0,1,2] #0 -> lecture, 1 -> ecriture, 2 -> les deux 

        #Pour chaque tâche du système de tâche, on choisi aléatoirement si elle écrira, lira des variables ou les deux 
        for taches in self.taches:
          action = random.choice(action_possible)

          #Si 0 est l'action choisie, alors on appelle la fonction qui selectionne x variables et qui les ajoute dans les caractéristiques de la tâche 
          if(action == 0):  
            taches.reads = self.get_Random_Variable_And_Store_It(variables_prenables)

          #Même chose si la tâche ne fait qu'écrire dans une variable 
          elif(action == 1):
            taches.writes = self.get_Random_Variable_And_Store_It(variables_prenables)

          #Même chose si la tâche écrit et lit 
          elif(action == 2):
            taches.reads = self.get_Random_Variable_And_Store_It(variables_prenables)
            taches.writes = self.get_Random_Variable_And_Store_It(variables_prenables)

    def detTestRnd(self):
      determinisme = True
      #Génération puis test des conditions de Bernstein sur 5 jeux de données différents
      for i in range(5):  
        self.get_Random_Dataset() #Ajoute des variables de lecture et/ou d'écriture à toute les tâches du système
        Bernstein_test(couple_a_Berstein) #Vérification du déterminisme en testant les cdtion de Berstein
        if(type(Bernstein_test==str)): #Si la fonction Berstein_test renvoi un string c'est un message d'erreur qui indique que le système n'est pas deterministe
          determinisme = False
        else:
          pass
      if(determinisme == True):
        print("Le résultat du test randomisé indique que le sysème de tâche est bien deterministe peu importe les variables")
      else:
        print("Le résultat du test randomisé indique que le sysème de tâche n'est pas deterministe")

     
    #-----------------------------------------------------RUN SEQUENTIEL -----------------------------------------------------------------

    # fonction pour exécuter une tâche
    def execute_task(self,task):
        print(f"Exécution de la tâche {task.name}")
        task.func()

    # fonction récursive pour exécuter les tâches
    def run_seq_intermediaire(self, task, completed_tasks):
        # vérifier si la tâche a déjà été exécutée
        if task in completed_tasks:
            return
        # exécuter les tâches dépendantes
        for dependent_task in self.dictPrec[task]:
            self.run_seq_intermediaire(dependent_task, completed_tasks)
        # exécuter la tâche actuelle
        self.execute_task(task)
        # ajouter la tâche terminée à la liste des tâches complétées
        completed_tasks.append(task)

    def runSeq(self):
        # exécuter les tâches dans l'ordre correct
        completed_tasks = []
        for task in self.dictPrec:
            self.run_seq_intermediaire(task, completed_tasks)


    #-------------------------------------------------------------- EXECUTION EN PARALELLE --------------------------------------------------------------------------------
    
            
    # fonction qui execute une tâche et ses dépendances
    def run_one_task(self, task):
        # attente des semaphores de toutes les tâches précédentes
        for dependency in self.dictPrec[task]:
              dependency.lock.acquire()
              
        # execution de la tâche
        print("Commencement de la tache", task.name )
        #task.acquire_lock() # verrouillage avant execution
        task.func()
        #task.release_lock() # deverouillage apres execution
        print("Tache", task.name, "terminée", " \n")
        
        # liberation des semaphores pour les tâches suivantes
        for dependent in task.dependents:
            dependent.lock.release()
            
    # fonction qui lance toutes les taches
    def run(self):
        # creation des threads pour toutes les tâches
        threads = [threading.Thread(target=self.run_one_task, args=(task,)) for task in self.dictPrec]

        # démarrage des threads
        for thread in threads:
            thread.start()


        # libération du sémaphore de la première tâche
        #T1.semaphore.release()
        
        # attente de la fin de tous les threads
        for thread in threads:
            thread.join()